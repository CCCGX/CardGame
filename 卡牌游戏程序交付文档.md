# 卡牌游戏程序交付文档

## 一、项目架构概述

### 1.1 架构设计理念

本项目采用 MVC（Model-View-Controller）架构模式，严格分离数据、视图与业务逻辑，确保代码的可维护性和可扩展性。各模块职责清晰、边界明确，通过规范的交互流程实现低耦合高内聚。

### 1.2 目录结构与核心模块职责

```typescript
Classes/
├── configs/       # 静态配置模块（关卡、卡牌资源等静态数据）
├── models/        # 数据模型模块（运行时动态数据与状态）
├── views/         # 视图模块（UI展示与用户输入捕获）
├── controllers/   # 控制器模块（协调模型与视图，处理业务逻辑）
├── managers/      # 管理器模块（提供专项服务，如撤销管理）
```

#### 各模块核心职责

*   **configs/**：存储静态配置（如`LevelConfig`存储关卡卡牌初始数据），通过加载器（如`LevelConfigLoader`）读取配置文件。
*   **models/**：维护运行时数据（如`GameModel`管理卡牌位置、状态；`UndoModel`存储撤销记录）。
*   **views/**：负责 UI 渲染（如`CardView`展示卡牌；`PlayFieldView`管理游戏区域布局），仅通过回调传递用户输入。
*   **controllers/**：处理业务逻辑（如`PlayFieldController`处理主牌区点击；`StackController`处理堆叠区逻辑），协调模型与视图交互。
*   **managers/**：提供专项服务（如`UndoManager`封装撤销逻辑），作为控制器的成员变量，不依赖控制器。

### 1.3 核心交互流程

用户交互遵循 “视图捕获输入→控制器处理逻辑→模型更新数据→视图反馈展示” 的流程，例如：

1.  用户点击卡牌 → `CardView`触发回调；

2.  控制器（如`PlayFieldController`）接收事件，调用`PlayFieldController`，验证合法性（通过`GameManager`）；

3.  控制器更新模型（如`GameModel`移动卡牌）并记录操作（通过`UndoManager`）；

4.  控制器调用视图接口（如`playMatchAnimation`）展示动画。

## 二、新增卡牌功能实现方案

### 2.1 需求说明

在现有游戏中新增一张卡牌（如 “ 大王 ”），需支持其在关卡中初始化、展示、交互及匹配逻辑。

### 2.2 实现步骤

#### 步骤 1：添加卡牌类型

*   **更新关卡配置文件**：在关卡 JSON 的`Playfield`或`Stack`数组中添加新卡牌配置：

*   **添加卡牌类型：**在`configs/CardConfig`，`views/CardView`，增加卡牌类型

#### 步骤 3：实现视图展示

*   `CardView`**自动支持新卡牌**：`createCard`方法已通过`CardSuitType`和`CardFaceType`加载对应资源。

*   **布局适配**：`PlayFieldView`的`initPlayFieldView`和`initStackView`会根据配置的`Position`自动布局新卡牌，无需额外代码。

#### 步骤 4：处理交互逻辑

*   **点击事件支持**：新卡牌的`CardView`会在初始化时绑定控制器回调（如`PlayFieldController::handleCardClick`），添加新的动画和回调函数，自动纳入现有交互流程。
*   **匹配规则验证**：`GameManager::canClick`会自动校验新卡牌与手牌区顶部牌，无需修改核心逻辑。

#### tips：若是新功能玩法卡牌

*   **更改交互逻辑和动画**：在`gameModel`和`gameManager`中添加新的交互逻辑的判断。在`view`层新增加点击动画，在`controller`层新加点击回调函数，并调用`gameManager`中的新逻辑判断方法。

## 三、新增回退功能实现方案

### 3.1 需求说明

新增一种回退类型：支持 “手牌区翻牌替换” 操作的回退（如回退 “用♥A 替换♣4” 的操作，使♣4 恢复为手牌区顶部牌）。

### 3.2 实现步骤

#### 步骤 1：扩展操作记录类型（models）

*   **更新**`ActionType`**枚举**（在`UndoModel.h`中）：

*   **扩展**`ActionRecord`**结构**（在`UndoModel.h`中）：存储回退所需的原始数据（如被替换的手牌 ID）：

#### 步骤 2：记录新操作（managers）

*   **在**`UndoManager`**中新增记录方法**（`UndoManager.cpp`）：

#### 步骤 3：实现回退逻辑（controllers & models）

*   **在**`StackController`**中处理回退触发**（`handleUndoClick`方法）：

*   **在**`UndoModel`**中新增恢复方法**

#### 步骤 4：添加回退动画（views）

*   **在**`PlayFieldView`**中新增动画方法**。

#### 步骤 5：集成到业务流程

*   **在 “手牌区翻牌替换” 逻辑中记录操作**（`StackController::handleCardClick`）：

### 3.3 新增回退功能的可扩展性说明

现有架构通过 “记录 - 恢复” 模式支持新增回退类型：

*   操作类型与数据通过`ActionRecord`扩展，无需修改原有记录逻辑；

*   回退逻辑集中在`UndoManager`和控制器，新增类型仅需添加分支处理；

*   视图动画通过新增方法实现，不影响现有动画逻辑。

## 四、总结

本项目通过 MVC 架构实现了数据、视图与逻辑的分离，各模块职责单一且交互规范。新增卡牌时，仅需扩展配置文件即可自动融入现有流程；新增回退功能时，通过扩展操作记录、补充恢复逻辑和动画即可实现，无需重构核心代码。

这种设计确保了代码的可维护性：

*   新增功能仅需修改对应模块，不影响其他逻辑；

*   模块间通过接口交互，便于替换或扩展（如替换`UndoManager`实现更复杂的回退策略）；

*   遵循编码规范（如注释、命名、职责边界），降低维护成本。
